---
layout: page
title: QR Factorization Techniques
---

QR Factorizations are a powerful method of decomposing a matrix intro triangular forms by using orthogonal transformations. Orthogonal transformations preserve the Euclidean matrix while factorizing the matrix so we can solve it using "normal" methods. A square matrix $$Q$$ is said to be orthogonal if $$Q^T Q = I$$. Using an orthogonal matrix, we can decompose an $$m \times n$$ matrix $$\bf{A}$$ into two matrices $$\bf{Q}$$ and $$\bf{R}$$, where

$$\bf{A} = \bf{Q}\begin{bmatrix}\bf{R}\\\bf{O}\end{bmatrix}$$

Here, $$\bf{Q}$$ is an $$m \times m $$ orthogonal matrix and $$\bf{R}$$ is an $$n \times n$$ upper triangular matrix. We can then use this to solve a much easier triangular least squares problem with the same solution, without going through worse math (since $$\bf{R}$$ is upper triangular).

To compute QR Factorizations, we can use three methods:

* Householder Transformations
* Givens transformations
* Gram-Schmidt orthogonalization

### Householder Transformations

(from Scientific Computing 1st ed, page 123)

With this method, we annihilate different components of the matrix until we're left with the matrix we want. We can generate a Householder transform $$\bf{H}$$ for a vector $$\bf{a}$$ by choosing a vector $$\bf{v}$$ such that:

$$\bf{Ha} = \begin{bmatrix}\alpha \\ 0 \\\vdots \\ 0\end{bmatrix} = \alpha\begin{bmatrix}1 \\ 0 \\\vdots \\ 0\end{bmatrix} = \alpha e_1$$

The Householder transform $$\bf{H}$$ is generated by:

$$\bf{H} = \bf{I} - 2\frac{\bf{vv^T}}{\bf{v^Tv}}$$

Reducing these two formulas, we find that

$$\bf{v} = \bf{a} - \alpha e_1$$

For a $$m$$-vector $$\bf{a}$$, consider splitting it into two parts:

$$\bf{a} = \begin{bmatrix}\bf{a_1}\\\bf{a_2}\end{bmatrix}$$

Here, $$\bf{a_1}$$ is a length $$k - 1$$ vector, where $$1 \leq k \leq m$$. Taking the Householder vector to be

$$\bf{v} = \begin{bmatrix}o\\\bf{a_2}\end{bmatrix} - \alpha e_k$$

Taking $$\alpha = -\text{sign}(a_k)\text{norm}(\bf{a_2})$$, the resulting Householder transformation will annihilate the last $$m-k$$ values of $$\bf{a}$$. Doing this for $$k = 1, \dots, n$$ will allow us to annihilate all subdiagonal entries of the original $$m \times n$$ matrix $$\bf{A}$$. The resulting algorithm is implemented below. $$

```python
def householder_qr(A):
    m, n = A.shape
    for k in range(0, n):
        a_k = A[:, k]
        alpha_k = -1*np.sign(A[k][k]) * np.linalg.norm(a_k)
        v_k = np.zeros(a_k.shape)
        v_k[k:m] = a_k[k:m]
        e_k = np.zeros(a_k.shape)
        e_k[k] = 1
        v_k = v_k - np.multiply(alpha_k, e_k) # if you want to compute Q, take all these vectors and multiply them
        beta_k = np.dot(v_k.T, v_k)
        if(beta_k == 0):
            continue
        for j in range(k, n):
            gamma_j = np.dot(v_k.T, A[:, j])
            A[:, j] = A[:, j] - (2*gamma_j / beta_k) * v_k
    return A

```

This algorithm returns the $$\bf{R}$$ matrix. If we want to get the $$\bf{Q}$$ matrix, we can take all the Householder transformations and multiply them together to return the $$\bf{Q}$$ matrix.
